name: Build New Asterisk Releases

on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - 'asterisk/supported-asterisk-builds.yml'

  push:
    branches:
      - main
    paths:
      - 'asterisk/supported-asterisk-builds.yml'

permissions:
  contents: read
  pull-requests: write
  packages: write

jobs:
  detect-new-releases:
    runs-on: ubuntu-latest
    outputs:
      new_versions: ${{ steps.extract-versions.outputs.new_versions }}
      has_new_versions: ${{ steps.extract-versions.outputs.has_new_versions }}

    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract new versions
        id: extract-versions
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "üîç Detecting new Asterisk versions in PR..."
            # Fetch base branch for comparison
            git fetch origin ${{ github.base_ref }}
            COMPARE_REF="origin/${{ github.base_ref }}"
          else
            echo "üîç Detecting new Asterisk versions in push to main..."
            # Compare with previous commit
            COMPARE_REF="HEAD^"
          fi

          # Get diff of supported-asterisk-builds.yml
          NEW_VERSIONS=$(git diff $COMPARE_REF...HEAD -- asterisk/supported-asterisk-builds.yml | \
            grep '^+.*version:' | \
            sed 's/^+.*version: *"\([^"]*\)".*/\1/' | \
            grep -v '^$' | \
            tr '\n' ' ' | \
            sed 's/ $//')

          if [ -z "$NEW_VERSIONS" ]; then
            echo "has_new_versions=false" >> $GITHUB_OUTPUT
            echo "new_versions=" >> $GITHUB_OUTPUT
            echo "üìã No new versions detected"
          else
            echo "has_new_versions=true" >> $GITHUB_OUTPUT
            echo "new_versions=$NEW_VERSIONS" >> $GITHUB_OUTPUT
            echo "üéâ New versions detected: $NEW_VERSIONS"
          fi

      - name: Comment on PR
        if: github.event_name == 'pull_request' && steps.extract-versions.outputs.has_new_versions == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const newVersions = '${{ steps.extract-versions.outputs.new_versions }}'.split(' ');
            const body = `## üéÜ New Asterisk Releases Detected

            This PR adds the following new versions:
            ${newVersions.map(v => '- `' + v + '`').join('\n')}

            üî® Building and pushing Docker images with \\\`-dev\\\` suffix for validation...

            **Note**: Images are pushed to registry with \\\`-dev\\\` tags (e.g., \\\`latest-dev\\\`, \\\`stable-dev\\\`) to distinguish from production builds.
            `;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: body
            });

  prepare-matrix:
    needs: detect-new-releases
    if: needs.detect-new-releases.outputs.has_new_versions == 'true'
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.generate-matrix.outputs.matrix }}
      total_builds: ${{ steps.generate-matrix.outputs.total_builds }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.13"

      - name: Install Python dependencies
        run: |
          pip install --user pyyaml

      - name: Generate build matrix for new versions only
        id: generate-matrix
        run: |
          python3 -c "
          import yaml
          import json
          import sys

          try:
              with open('asterisk/supported-asterisk-builds.yml', 'r') as f:
                  data = yaml.safe_load(f)

              matrix = {'include': []}
              new_versions_str = '${{ needs.detect-new-releases.outputs.new_versions }}'
              new_versions = [v.strip() for v in new_versions_str.split() if v.strip()]

              print(f'üéØ Filtering for new versions: {new_versions}', file=sys.stderr)

              total_configs = 0

              for build in data.get('latest_builds', []):
                  version = build.get('version')
                  if not version:
                      continue

                  # Only process new versions
                  if version not in new_versions:
                      continue

                  if 'os_matrix' not in build:
                      print(f'‚è≠Ô∏è  Skipping {version} (no os_matrix - disabled)', file=sys.stderr)
                      continue

                  os_matrix = build['os_matrix']
                  additional_tags = build.get('additional_tags', '')

                  if isinstance(os_matrix, dict):
                      os_matrix = [os_matrix]

                  for matrix_entry in os_matrix:
                      os_name = matrix_entry.get('os', 'debian')
                      distribution = matrix_entry.get('distribution', 'trixie')
                      architectures = matrix_entry.get('architectures', ['amd64'])

                      architectures_str = ','.join(architectures)
                      matrix_item = {
                          'version': version,
                          'distribution': distribution,
                          'architectures': architectures_str,
                          'os': os_name
                      }

                      # Add additional_tags if present
                      if additional_tags:
                          matrix_item['additional_tags'] = additional_tags

                      matrix['include'].append(matrix_item)
                      total_configs += 1

                      tags_info = f' +tags: {additional_tags}' if additional_tags else ''
                      print(f'‚úÖ Added: {version} {os_name}/{distribution} [{architectures_str}]{tags_info}', file=sys.stderr)

              if total_configs == 0:
                  print('‚ùå No buildable configurations found for new versions!', file=sys.stderr)
                  sys.exit(1)

              print(f'üìä Generated {total_configs} build configurations for new versions', file=sys.stderr)
              print('matrix=' + json.dumps(matrix))
              print('total_builds=' + str(total_configs))

          except Exception as e:
              print(f'‚ùå ERROR: Failed to parse YAML: {e}', file=sys.stderr)
              sys.exit(1)
          " | tee -a $GITHUB_OUTPUT

  build-matrix:
    needs: [detect-new-releases, prepare-matrix]
    if: needs.detect-new-releases.outputs.has_new_versions == 'true'
    strategy:
      matrix: ${{ fromJson(needs.prepare-matrix.outputs.matrix) }}
      fail-fast: false
      max-parallel: 5

    uses: ./.github/workflows/build-single-image.yml
    with:
      version: ${{ matrix.version }}
      distribution: ${{ matrix.distribution }}
      architectures: ${{ matrix.architectures }}
      additional_tags: ${{ matrix.additional_tags || '' }}
      push: true  # Always push for multi-platform builds (PR = -dev suffix, main = production)
      registry: 'andrius/asterisk'
    secrets: inherit

  report-results:
    needs: [detect-new-releases, prepare-matrix, build-matrix]
    runs-on: ubuntu-latest
    if: always() && github.event_name == 'pull_request' && needs.detect-new-releases.outputs.has_new_versions == 'true'

    steps:
      - name: Comment build results on PR
        uses: actions/github-script@v7
        with:
          script: |
            const newVersions = '${{ needs.detect-new-releases.outputs.new_versions }}'.split(' ');
            const totalBuilds = '${{ needs.prepare-matrix.outputs.total_builds }}';
            const buildResult = '${{ needs.build-matrix.result }}';

            let status = '';
            let emoji = '';

            if (buildResult === 'success') {
              status = 'All builds passed';
              emoji = '‚úÖ';
            } else if (buildResult === 'failure') {
              status = 'Some builds failed';
              emoji = '‚ùå';
            } else {
              status = 'Builds cancelled or skipped';
              emoji = '‚ö†Ô∏è';
            }

            const body = `## ${emoji} Build Results for New Releases

            **Status**: ${status}
            **Versions**: ${newVersions.map(v => '`' + v + '`').join(', ')}
            **Total configurations**: ${totalBuilds}

            ${buildResult === 'success' ?
              '‚úÖ All Docker images built and pushed successfully with `-dev` suffix! Safe to merge.' :
              '‚ùå Build failures detected. Please review the workflow logs before merging.'}

            **Note**: Images are pushed to registry with \\\`-dev\\\` tags for validation. Production tags will be created after merging to main.
            `;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: body
            });

  announce-releases:
    needs: [detect-new-releases, prepare-matrix, build-matrix]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.detect-new-releases.outputs.has_new_versions == 'true' && needs.build-matrix.result == 'success'

    steps:
      - name: Prepare announcement message
        id: message
        run: |
          NEW_VERSIONS="${{ needs.detect-new-releases.outputs.new_versions }}"
          VERSION_LIST=$(echo "$NEW_VERSIONS" | tr ' ' '\n' | sed 's/^/- /' | tr '\n' ' ')

          MESSAGE="üéÜ New Asterisk Docker Images Released!

          Versions:
          ${VERSION_LIST}

          Available on:
          - Docker Hub: docker.io/andrius/asterisk
          - GitHub Container Registry: ghcr.io/andrius/asterisk

          Pull with: docker pull andrius/asterisk:VERSION

          GitHub: https://github.com/${{ github.repository }}
          "

          # Format for Telegram (escape special characters)
          TELEGRAM_MESSAGE=$(echo "$MESSAGE" | sed 's/[_*[\]()~`>#+=|{}.!-]/\\&/g')

          # Format for Mastodon (plain text)
          MASTODON_MESSAGE="$MESSAGE"

          echo "telegram_message<<EOF" >> $GITHUB_OUTPUT
          echo "$TELEGRAM_MESSAGE" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "mastodon_message<<EOF" >> $GITHUB_OUTPUT
          echo "$MASTODON_MESSAGE" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Announce on Telegram
        if: vars.TELEGRAM_CHAT_ID != ''
        uses: appleboy/telegram-action@v1.0.0
        with:
          to: ${{ vars.TELEGRAM_CHAT_ID }}
          token: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          message: ${{ steps.message.outputs.telegram_message }}
          format: markdown

      - name: Announce on Mastodon
        if: vars.MASTODON_URL != ''
        uses: cbrgm/mastodon-github-action@v2.1.8
        with:
          access-token: ${{ secrets.MASTODON_ACCESS_TOKEN }}
          url: ${{ vars.MASTODON_URL }}
          message: ${{ steps.message.outputs.mastodon_message }}
